---
title: Numpy、Pandas 学习笔记
date: 2019-05-05
categories: [科研]
tags: [学习笔记, 技术]
img_path: /assets/img/
---

Numpy 和 Pandas 这些数据处理的库，真的是很容易混淆，也不知道什么时候该用什么。这篇文章我想一次性解决有关它们的所有疑点。

[Numpy 官方文档在这里！]() [Pandas 官方文档在这里！]()

### 表示法

张量可以用一个用中括号嵌套的字符串表示，例：

0阶：`1`
1阶：`[1,2,3]`
2阶：`[[1,0,0],[0,1,0],[0,0,1]]`
3阶：`[[[1,2],[3,4]],[[-1,-2],[-3,-4]]]`

用处就是在构造或打印的时候，都是以这种格式表示的。张量的阶数即中括号的嵌套层数。


可以看到，张量的**阶数**是严格规定的，在数学上 $$n$$ 维向量经常可以看成 $$n\times 1$$ 的矩阵，但是在包括 PyTorch、Numpy 这些框架中，就是 1 阶张量和 2 阶张量的区别，使用不当会报错。

同理，所以数 `1` 和1阶张量 `[1]`、2阶张量 `[[1]]` 是不一样的。 另外注意 0 阶张量虽然在逻辑上就是一个数，但也是 tensor 类型，必要时应转换。

张量的**形状**可以用一个 **size 数组**表示，上面几个例子形状分别为 `[], [3], [3,3], [2,2,2]`。


### 广播机制

**广播**（broadcast）机制是指两个**形状不同**的张量执行**按元素操作**所遵循的规则。[官方文档](https://pytorch.org/docs/stable/notes/broadcasting.html)中规定了广播机制的限定条件：

![broadcast](/assets/img/broadcastable.png)

说白了就是比较两个张量的形状：如果阶数不同，则在最高阶处（size 数组最左边）补齐维数为 1 维；如果阶数相同，则检查每一维维数是否要么为 1 要么相等。

广播机制的操作是将两个张量 1 维的那些维度**复制** $$n$$ 份（$$n$$ 为对方对应维度的维数），再进行按元素操作。书上的一个例子：

` a = [[0],[1],[2]], b = [[0,1]], 则 a + b = [[0,1],[1,2],[2,3]] `

`a,b` 的形状分别是 `[3,1], [1,2]`，经过广播复制后分别变为形状为 `[3,2],[2,2]` 的 `[[0,0],[1,1],[2,2]], [[0,1],[0,1],[0,1]]`，再进行相加操作。 



广播机制不仅是形式上的：经常会极大简化深度学习的代码，主要是效率上的：它在背后使用了比 for 循环高效得多的实现方式。

它带给我们方便，也会偶尔带来麻烦：如果在无意识的情况下触发到它，可能就是一个很棘手的 bug。所以要写代码时要时刻盯好 tensor 的形状。


